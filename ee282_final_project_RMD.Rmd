---
title: "R Notebook for ee282 final project report"
output: html_notebook
---
#### Junyan Duan
```{r}
library(Seurat)
library(dplyr)
library(cowplot)
library(ggplot2)
library(Matrix)
library(scales)
library(fields)
library(reshape)
library(corrplot)
library(xlsx)
```

#### Spaghetti plot
```{r}
# get expression data for some core clock genes
clock.genes = c("Arntl", "Clock", "Npas2", "Per1", "Per2", "Per3","Cry1", "Nr1d1", "Nr1d2", "Rora", "Rorb", "Dbp", "Nfil3", "Tef", "Hlf", "Bhlhe41", "Ciart")
clock.expression=FetchData(scn.whole,c("ident","CT", "batchNum", clock.genes))
# rescale the expression level so between 0 and 1 for every gene
for (i in 4:(3+length(clock.genes))){
  clock.expression[,i] = rescale(clock.expression[,i])
}
```
#### spaghetti plot function
```{r}
spaghettiTime = function(cell.type, ct, gene.list, cell.group.max, cell.per.group){
  clock.expression.type = as.data.frame(clock.expression %>% filter(ident == cell.type))
clock.gene.ct.matrix = matrix(0,cell.group.max*length(ct), 3+length(gene.list)) 
clock.random.sample = setNames(data.frame(matrix(ncol = 3+length(gene.list), nrow = 0)), c("ident","CT","batchNum", gene.list))
for (c in 1: cell.group.max){
clock.gene.ct.matrix[,2] = cell.type
clock.gene.ct.matrix[(length(ct)*c-11):(length(ct)*c),1] = c
for (t in 1:length(ct)){
  time.point = ct[t]
  clock.expression.ct = clock.expression.type %>% filter(CT == time.point)
  clock.group = clock.expression.ct[sample(nrow(clock.expression.ct), cell.per.group), ]
  clock.random.sample = rbind(clock.random.sample,clock.group)
  for (g in 1:length(gene.list)){
    clock.gene.ct.matrix[(c-1)*length(ct)+t, 3] = ct[t]
    clock.gene.ct.matrix[(c-1)*length(ct)+t, 3+g] = mean(clock.group[,3+g])
  }
}
}

clock.gene.ct.matrix<-as.data.frame(clock.gene.ct.matrix)
names(clock.gene.ct.matrix)[4:(length(gene.list)+3)]<-gene.list
names(clock.gene.ct.matrix)[1]<- "groupID"
names(clock.gene.ct.matrix)[2]<- "celltype"
names(clock.gene.ct.matrix)[3]<- "CT"
for (i in 4:(3+length(gene.list))) {
  clock.gene.ct.matrix[,i] = as.numeric(as.character(clock.gene.ct.matrix[,i]))
}
clock.gene.ct.matrix$groupID <- as.numeric(as.character(clock.gene.ct.matrix$groupID))
return(list(clock.gene.ct.matrix = clock.gene.ct.matrix, clock.random.sample = clock.random.sample))
}
```
#### spaghetti plot for neurons
```{r}
ct.list = c("CT14", "CT18", "CT22", "CT26", "CT30", "CT34", "CT38", "CT42", "CT46", "CT50", "CT54", "CT58")
spaghettiresults_ependymal = spaghettiTime(cell.type = "ependymal cells", ct = ct.list, cell.group.max = 50, cell.per.group = 50, gene.list = clock.genes)
spaghettiresults_neurons = spaghettiTime(cell.type = "neurons", ct = ct.list, cell.group.max = 50, cell.per.group = 50, gene.list = clock.genes)
```

```{r}
# ggplot
ggplot() +
  geom_point(data = spaghettiresults_ependymal$clock.gene.ct.matrix, size = 1, aes(x = CT, y = Per2, group = groupID, colour = groupID))+
  geom_line(data = spaghettiresults_ependymal$clock.gene.ct.matrix, aes(x = CT, y = Per2, group = groupID, colour = groupID))+
 # geom_point(data = spaghettiresults_neurons$clock.random.sample, aes(x = CT, y = Dbp), colour = "palevioletred" )+
  ggtitle("Ependymal cells: expression level of Per2")+ylim(0,0.35)
```

```{r}
average_lines = spaghettiresults_ependymal$clock.gene.ct.matrix %>% group_by(CT) %>% summarise_at(vars(clock.genes), mean)
average_lines = as.data.frame(average_lines)
average_lines_melt = melt(average_lines, id.vars = "CT")
# ggplot
ggplot(average_lines_melt, aes(x = CT, y = value, color = variable, group = variable))+
  geom_line()+ggtitle("Neurons: average expression of core clock genes")+ylim(0,0.3)
```
#### Correlation between expression level of core clock genes
```{r}
gene.cor.score= matrix(0, length(clock.genes), length(clock.genes))
gene.cor.pvalue = matrix(0,length(clock.genes),length(clock.genes))
cor.data = average_lines[, -1]
for ( i in 1:length(clock.genes)){
  pi.shapiro = shapiro.test(cor.data[,i])$p.value
  if (pi.shapiro>0.05){
    for (j in 1:length(clock.genes)) {
      pj.shapiro = shapiro.test(cor.data[,j])$p.value
      if (pj.shapiro >0.05){
        gene.cor.test = cor.test(cor.data[,i], cor.data[,j], method = "pearson")
        gene.cor.score[i,j] = gene.cor.test$estimate
        gene.cor.pvalue[i,j] = gene.cor.test$p.value
      }
    }
  }
}

gene.cor.score = as.data.frame(gene.cor.score, row.names = clock.genes)
colnames(gene.cor.score)= clock.genes 
gene.cor.score =gene.cor.score[apply(gene.cor.score[,-1], 1, function(x) !all(x==0))]
gene.cor.score =gene.cor.score[apply(gene.cor.score[,-1], 1, function(x) !all(x==0)),]
gene.cor.score = as.matrix(gene.cor.score)
gene.cor.pvalue = as.data.frame(gene.cor.pvalue, row.names = clock.genes)
colnames(gene.cor.pvalue)= clock.genes 
gene.cor.pvalue =gene.cor.pvalue[apply(gene.cor.pvalue[,-1], 1, function(x) !all(x==0))]
gene.cor.pvalue =gene.cor.pvalue[apply(gene.cor.pvalue[,-1], 1, function(x) !all(x==0)),]
gene.cor.pvalue = as.matrix(gene.cor.pvalue)
### run below after identifying overlapping genes
significant.genes = c( "Clock" , "Per1", "Nr1d1", "Nr1d2", "Rora", "Dbp", "Nfil3", "Tef", "Hlf", "Bhlhe41")
sig.gene.cor.pvalue = gene.cor.pvalue[significant.genes, significant.genes]
sig.gene.cor.score = gene.cor.score[significant.genes, significant.genes]
```

```{r}
corrplot(sig.gene.cor.score, method="circle", order="hclust", 
         p.mat = sig.gene.cor.pvalue, sig.level = 0.05, type = "upper",mar=c(0,0,2,0))
title("Ependymal cells: Correlation plot for core clock genes")
```

















